library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity fp_adder is
    port (
        a, b : in std_logic_vector (31 downto 0);
        s    : out std_logic_vector (31 downto 0));
end fp_adder;

architecture behavioral of fp_adder is
    -- signal declaration
    -- split input signals into their parts
    signal s_a, s_b : std_logic;
    signal e_a, e_b : std_logic_vector (7 downto 0);
    signal m_a, m_b : std_logic_vector (22 downto 0);

begin
    main : process
    begin
        -- split input signals into their parts
        s_a <= a (31);
        s_b <= b (31);
        e_a <= a (30 downto 23);
        e_b <= b (30 downto 23);
        m_a <= a (22 downto 0);
        m_b <= b (22 downto 0);

        -- deal with special cases
        if (e_a = b"1111_1111") or (e_b = b"1111_1111") then
            
                -- if both operands are infinity:
            elsif (e_a = b"1111_1111" and m_a = b"000_0000_0000_0000_0000_0000") and (e_b = b"1111_1111" and m_b = b"000_0000_0000_0000_0000_0000") then
                -- if their signs are different => output is NaN
                if s_a /= s_b then
                    s <= b"0_1111_1111_000_0000_0000_0000_0000_0001";
                    -- if their signs are the same => output is infinity of the same sign as the inputs
                else
                    s <= s_a & b"1111_1111_000_0000_0000_0000_0000_0000";
                end if;
                -- if the first operand only is infinity and the second is a real number => output is infinity
            elsif (e_a = b"1111_1111" and m_a = b"000_0000_0000_0000_0000_0000") then
                s <= s_a & b"1111_1111_000_0000_0000_0000_0000_0000";
                -- if the second operand only is infinity and the first is a real number => output is infinity
            elsif (e_b = b"1111_1111" and m_b = b"000_0000_0000_0000_0000_0000") then
                s <= s_b & b"1111_1111_000_0000_0000_0000_0000_0000";
                -- all special cases should be covered here
            else
                s <= "--------------------------------";
                end if;
            end if;
        end process main;
        --     -- component declaration

        --     -- signal declaration
        --     -- input and output signals signs
        --     signal a_s, b_s, s_s            : std_logic;
        --     -- input and output signals exponents
        --     signal a_e, b_e, s_e            : std_logic_vector (7 downto 0);
        --     -- input and output signals mantissas
        --     signal a_m, b_m, s_m            : std_logic_vector (22 downto 0);

        --     -- temporary signal used for radix alignment process
        --     signal shift_needed             : unsigned (7 downto 0);

        --     -- intermediate exponent signals
        --     signal e_intermediate           : unsigned (7 downto 0);
        --     -- intermediate radix aligned signals
        --     -- these include the hidden bit
        --     signal a_m_aligned, b_m_aligned : unsigned (24 downto 0); -- TODO: these don't have the right bit length I think...

        --     -- signed versions of radix aligned operands
        --     signal a_signed, b_signed       : signed (25 downto 0);

        --     -- intermediate sum signal with one extra bit for overflow
        --     signal intermediate_sum         : signed (25 downto 0);

        --     -- intermediate signal for mantissa of sum (still includes hidden bit)
        --     signal intermediate_mantissa    : unsigned (24 downto 0);

        -- begin
        --     -- concurrent statements
        --     a_s <= a(31);
        --     b_s <= b(31);
        --     a_e <= a(30 downto 23);
        --     b_e <= b(30 downto 23);
        --     a_m <= a(22 downto 0);
        --     b_m <= b(22 downto 0);

        --     radix_point_alignment : process (shift_needed, e_intermediate, a_m_aligned, b_m_aligned)
        --     begin
        --         if a_e = b_e then
        --             -- leave all signals as they are
        --             e_intermediate <= unsigned(a_e);

        --             -- add hidden bit
        --             if a_e = "00000000" then
        --                 a_m_aligned <= unsigned('0' & a_m);
        --             else
        --                 a_m_aligned <= unsigned('1' & a_m);
        --             end if;

        --             if b_e = "00000000" then
        --                 b_m_aligned <= unsigned('0' & b_m);
        --             else
        --                 b_m_aligned <= unsigned('1' & b_m);
        --             end if;

        --         elsif a_e > b_e then
        --             -- shift b_m by the difference of a_e and b_e
        --             shift_needed   <= unsigned(a_e) - unsigned(b_e);
        --             -- both exponents end up the same
        --             e_intermediate <= unsigned(a_e);
        --             -- add hidden bit to a's mantissa
        --             if a_e = "00000000" then
        --                 a_m_aligned <= unsigned('0' & a_m);
        --             else
        --                 a_m_aligned <= unsigned('1' & a_m);
        --             end if;
        --             -- add hidden bit then shift b's mantissa
        --             if b_e = "00000000" then
        --                 b_m_aligned <= shift_left(unsigned('0' & b_m), to_integer(shift_needed));
        --             else
        --                 b_m_aligned <= shift_left(unsigned('1' & b_m), to_integer(shift_needed));
        --             end if;

        --         else
        --             -- shift a_m by the difference of b_e and a_e
        --             shift_needed   <= unsigned(b_e) - unsigned(a_e);
        --             -- both exponents end up the same
        --             e_intermediate <= unsigned(b_e);
        --             -- add hidden bit to b's mantissa
        --             if b_e = "00000000" then
        --                 b_m_aligned <= unsigned('0' & b_m);
        --             else
        --                 b_m_aligned <= unsigned('1' & b_m);
        --             end if;
        --             -- add hidden bit then shift a's mantissa
        --             if a_e = "00000000" then
        --                 a_m_aligned <= shift_left(unsigned('0' & a_m), to_integer(shift_needed));
        --             else
        --                 a_m_aligned <= shift_left(unsigned('1' & a_m), to_integer(shift_needed));
        --             end if;
        --         end if;
        --     end process radix_point_alignment;

        --     mantissa_addition : process (intermediate_sum)
        --     begin
        --         -- get signed version of operands and duplicate MSB to prevent overflow
        --         if a_s = '1' then
        --             a_signed <= resize(-1 * signed(a_m_aligned), 26);
        --         else
        --             a_signed <= resize(signed(a_m_aligned), 26);
        --         end if;
        --         if b_s = '0' then
        --             b_signed <= resize(-1 * signed(b_m_aligned), 26);
        --         else
        --             b_signed <= resize(signed(b_m_aligned), 26);
        --         end if;
        --         -- perform addition
        --         intermediate_sum <= a_signed + b_signed;
        --     end process mantissa_addition;

        --     normalization : process (intermediate_mantissa, s_s, s_e, s_m)
        --     begin
        --         -- strip sign
        --         if intermediate_sum < 0 then
        --             s_s                   <= '1';
        --             intermediate_mantissa <= unsigned(-1 * intermediate_sum);
        --         else
        --             s_s                   <= '0';
        --             intermediate_mantissa <= unsigned(intermediate_sum);
        --         end if;
        --         -- if there was an overflow during addition, increment exponents and right shift mantissa
        --         if intermediate_sum(25 downto 24) = "10" or intermediate_sum(25 downto 24) = "01" then
        --             -- overflow may lead to positive or negative infinity
        --             if e_intermediate = 254 then
        --                 s_e                   <= b"1111_1111";
        --                 intermediate_mantissa <= 0;
        --             else
        --                 s_e                   <= std_logic_vector(e_intermediate + 1);
        --                 intermediate_mantissa <= shift_right(intermediate_mantissa, 1);
        --             end if;
        --         end if;
        --         -- normalize by shifting left if hidden bit is 0
        --         if intermediate_mantissa(intermediate_mantissa'high) = '0' then
        --             if e_intermediate = 0 then
        --                 -- do nothing
        --             elsif intermediate_mantissa = 0 then
        --                 -- do nothing (s_m = 0, s_e = 0)
        --             else
        --                 -- shift bits to right positions and decrement exponent (stop at exponent = 0)
        --             end if;
        --         end if;
        --         -- special cases
        --     end process normalization;

        --     -- rounding is not necessary in our implementation since the sum already has the right bitlength
    end behavioral;
